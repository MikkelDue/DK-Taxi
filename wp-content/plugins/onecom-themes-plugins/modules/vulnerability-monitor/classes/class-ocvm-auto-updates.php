<?php


class OCVMAutoUpdates
{
    use OCVMVulnerabilities;
    public $updateAttempt = [
        'time' => '',
        'failed' => [],
        'successful' => []
    ];
    private $settings;
    private $items;
    const PLUGINS_PACKAGE_URL = "https://downloads.wordpress.org/plugin/%s.%s.zip";
    const THEMES_PACKAGE_URL = "https://downloads.wordpress.org/theme/%s.%s.zip";
    const WP_PACKAGE_URL = "https://downloads.wordpress.org/release/%s/wordpress-%s.zip";
    const WP_PACKAGE_NO_CONTENT_URL = "https://downloads.wordpress.org/release/wordpress-%s-no-content.zip";
    const ERROR_DESCRIPTION = "Error description --> ";
    const WP_UPGRADER_FILE_PATH = 'wp-admin/includes/class-wp-upgrader.php';
    const WP_FILE_SYSTEM_PATH = 'wp-admin/includes/file.php';
    const WP_MISC_PATH = 'wp-admin/includes/misc.php';

    public function __construct()
    {
        $this->settings = new OCVMSettings();

        // ???
    }

    /**
     * Get FQN of plugin by slug
     * @param $slug string Plugin's PHP file name (without extension)
     * @return string directory/plugin_file.php
     */
    protected function find_plugin_for_slug($slug)
    {
        require_once ABSPATH . 'wp-admin/includes/plugin.php';
        $plugin_files = get_plugins('/' . $slug);
        if (!$plugin_files) {
            return '';
        }
        $plugin_files = array_keys($plugin_files);
        return $slug . '/' . reset($plugin_files);
    }

    /**
     * Prepare update attempt records
     */
    public function prepareAttempt($type, $slug, $new_ver, $itemFQN, $itemData)
    {
        $attempt = array(
            'type' => $type,
            'slug' => $slug,
            'dir' => $itemFQN,
            'new_version' => $new_ver,
            'time' => time()
        );

        if (!empty($itemData)) {
            $attempt['name'] = $itemData['Name'];
            $attempt['old_version'] = $itemData['Version'];
        }

        // get latest state from DB
        $settings = $this->settings->get();

        if ("wp" === $type) {
            $vuls = $settings['vulnerabilities'][$type]['vulnerabilities'];
        } else {
            $vuls = $settings['vulnerabilities'][$type][$slug]['vulnerabilities'];
        }

        foreach ( $vuls as $v ) {
            // modified to manipulate the vuln_type string and url recieved from new API
            $desc = "wp_vul_" . strtolower( str_replace( [ " ", "(", ")" ], [ "_", "", "" ], $v['vuln_type'] ) );
            if ( $this->vulTranslation( $desc ) !== '' ) {
                $attempt['vuls'][ $v['id'] ]['id'] = $this->vulTranslation( $desc );

            } elseif ( $this->vulTranslation( $attempt['vuls'][ $v['id'] ]['id'] ) === '' && isset( $v['description'] ) ) {
                $attempt['vuls'][ $v['id'] ]['id'] = $v['description'];
            } else {
                $attempt['vuls'][ $v['id'] ]['id'] = __('wp_vul_unknown', OC_PLUGIN_DOMAIN);
            }
            $attempt['vuls'][ $v['id'] ]['url'] = $v['url'];
        }

        return $attempt;
    }

    /**
     * Update item records after attempting their update
     * @param string $type
     * @param string $slug
     * @param array $attempt
     * @return void
     */
    public function updateItemRecords($type, $slug, $attempt = []): void
    {
        // seat belt
        if (empty($type) || empty($slug)) {
            error_log("Failed to update records because either 'itemType' or 'itemSlug' or both are empty.");
            return;
        }

        // get latest state from DB
        $settings = $this->settings->get();

        // remove the item from vulnerabilities list.
        // in case of WP, clear the array.
        if('wp' === $type){
            $settings['vulnerabilities'][$type]  = [];
        }
        else{
            // remove the item for which we have attempted an update
            unset($settings['vulnerabilities'][$type][$slug]);
        }


        // save the current attempt of item updates in database
        if (!empty($attempt)) {
            $settings['update_attempts'] = $this->updateAttempt;
        }

        $this->settings->update($settings);
    }


    /** Update single plugin
     * @param $type string Type of item (plugins)
     * @param $slug string Filename of the item
     * @param $ver string Desired version for update
     * @return void
     */
    public function updateTypePlugins($type, $slug, $ver)
    {

        // get all details of the plugin using slug
        $pluginFQN = $this->find_plugin_for_slug($slug);

        if (empty($pluginFQN)) {
            error_log("Skipping update by rule...[Plugin '{$slug}' no longer exists]");

            // (remove this item from database) update records for this item
            $this->updateItemRecords($type, $slug);
            return;
        }

        if (false === is_plugin_active($pluginFQN)) {
            error_log("Skipping update by rule...[Plugin '{$slug}' is no longer active]");

            // (remove this item from database) update records for this item
            $this->updateItemRecords($type, $slug);
            return;
        }

        // load plugin functions to get plugin headers
        if (!function_exists('get_plugin_data')) {
            require_once(ABSPATH . 'wp-admin/includes/plugin.php');
        }

        // plugin headers by plugin dir
        // e.g., /../../../../../test-plugin/test-plugin.php
        $pluginData = get_plugin_data(trailingslashit(WP_PLUGIN_DIR) . $pluginFQN);
        // exit if fixed_version and current versions are same.
        if ((string)$ver === (string)$pluginData['Version']) {
            error_log("Skipping update by rule...[Plugin '{$slug}' is already at the 'fixed' version]");

            // (remove this item from database) update records for this item
            $this->updateItemRecords($type, $slug);
            return;
        }

        // record update attempt details
        $attempt = $this->prepareAttempt($type, $slug, $ver, $pluginFQN, $pluginData);

        error_log("#################################");
        error_log("##### starting update of {$slug}");
        error_log("#################################");

        $pluginObj = new stdClass();
        $pluginObj->slug = $slug;
        $pluginObj->plugin = $pluginFQN;
        $pluginObj->new_version = $ver;
        $pluginObj->package = sprintf(self::PLUGINS_PACKAGE_URL, $slug, $ver);


        $current = get_site_transient('update_plugins');
        if(!is_object($current)){
            $current = new stdClass();
        }
        $current->response[$pluginFQN] = $pluginObj;
        set_site_transient('update_plugins', $current);

		require_once ABSPATH . self::WP_FILE_SYSTEM_PATH;
        require_once ABSPATH . self::WP_UPGRADER_FILE_PATH;
        require_once ABSPATH . self::WP_MISC_PATH;
	  	wp_cache_flush();
        $upgrader = new Plugin_Upgrader();
        $result = $upgrader->upgrade($pluginFQN);

        // modified to handle the null result in case of failed plugin downloads may be due to the non-working url of plugin zip
        if (is_wp_error($result) || !$result) {

            //TODO: handle failed updates - perhaps send an email and remove records from DB

            // keep status of update
            $this->updateAttempt['failed'][] = $attempt;
            error_log("Error occurred during update of plugin --> " . $pluginFQN);
            // added for the case when update fails may be due to the non-working url of plugin zip
            $err_description = !is_null($result)?json_encode($result->get_error_message()):'Plugin download failed for some reason.';
            error_log(self::ERROR_DESCRIPTION . $err_description);
        } else {

            // keep status of update
            $this->updateAttempt['successful'][] = $attempt;

            error_log("Updated {$slug} successfully --> " . $pluginFQN);
        }

        // update records for this item
        $this->updateItemRecords($type, $slug, $this->updateAttempt);

    }


    /**
     * Update single theme
     * @param $type string Type of item (themes)
     * @param $slug string Filename of the item
     * @param $ver string Desired version for update
     * @return void
     */
    public function updateTypeThemes($type, $slug, $ver)
    {

        // theme headers
        $themeData = wp_get_theme($slug);

        // check if theme exists
        if (false === $themeData->exists()) {
            error_log("Skipping update by rule...[Theme '{$slug}' no longer exists]");

            // (remove this item from database) update records for this item
            $this->updateItemRecords($type, $slug);
            return;
        }

        // check if theme is active
        if (get_site_option('template') !== $themeData->template) {
            error_log("Skipping update by rule...[Theme '{$slug}' is no longer active]");

            // (remove this item from database) update records for this item
            $this->updateItemRecords($type, $slug);
            return;
        }


        // exit if fixed_version is equal to current versions are same.
        if ((string)$ver === (string)$themeData->get('Version')) {
            error_log("Skipping update by rule...[Theme '{$slug}' is already at the 'fixed' version]");

            // (remove this item from database) update records for this item
            $this->updateItemRecords($type, $slug);
            return;
        }

        // record update attempt details
        $attempt = $this->prepareAttempt($type, $slug, $ver, $themeData->stylesheet, $themeData);

        error_log("#################################");
        error_log("##### starting update of {$slug}");
        error_log("#################################");


        $themeObj['theme'] = $themeData->template;
        $themeObj['new_version'] = $ver;
        $themeObj['package'] = sprintf(self::THEMES_PACKAGE_URL, $slug, $ver);


        $current = get_site_transient('update_themes');
        $current->response[$themeData->template] = $themeObj;
        set_site_transient('update_themes', $current);

		require_once ABSPATH . self::WP_FILE_SYSTEM_PATH;
        require_once ABSPATH . self::WP_UPGRADER_FILE_PATH;
        require_once ABSPATH . self::WP_MISC_PATH;
	  	wp_cache_flush();
        $upgrader = new Theme_Upgrader();
        $result = $upgrader->upgrade($themeData->template);

        if (is_wp_error($result)) {

            //TODO: handle failed updates - perhaps send an email and remove records from DB

            // keep status of update
            $this->updateAttempt['failed'][] = $attempt;

            error_log("Error occurred during update of theme --> " . $themeData->template);
            error_log(self::ERROR_DESCRIPTION . json_encode($result->get_error_message()));
        } else {

            // keep status of update
            $this->updateAttempt['successful'][] = $attempt;

            error_log("Updated {$slug} successfully --> " . $themeData->template);
        }

        // update records for this item
        $this->updateItemRecords($type, $slug, $this->updateAttempt);

    }


    /**
     * Update single theme
     * @param $type string Type of item (themes)
     * @param $slug string Filename of the item
     * @param $ver string Desired version for update
     * @return void
     */
    public function updateTypeWp($type, $slug, $ver)
    {
        global $wpdb, $wp_version;

        if (version_compare($wp_version, $ver) >= 0) {
            error_log("Skipping update by rule...[WP core is already at a greater or equal version than provided version i.e., {$wp_version} >= {$ver}]");

            // (remove this item from database) update records for this item
            $this->updateItemRecords($type, $slug);
            return;
        }

        $itemData = array(
            'Name' => 'WordPress core',
            'Version' => $wp_version
        );
        // record update attempt details
        $attempt = $this->prepareAttempt($type, $slug, $ver, '', $itemData);

        error_log("attempt for WP  ==> ".json_encode($attempt));

        error_log("#################################");
        error_log("##### starting update to WP core v{$ver}");
        error_log("#################################");

        $locale = apply_filters('core_version_check_locale', get_locale());

        $wpObj = new stdClass();
        $wpObj->response = 'upgrade';
        $wpObj->download = sprintf(self::WP_PACKAGE_URL, $locale, $ver);
        $wpObj->locale = $locale;
        $wpObj->current = $wp_version;
        $wpObj->version = $wp_version;
        $wpObj->php_version = phpversion();
        $wpObj->mysql_version = preg_replace('/[^0-9.].*/', '', $wpdb->db_version());
        $wpObj->new_bundled = $wp_version;

        $package = new stdClass();
        $package->full = $wpObj->download;
        $package->no_content = sprintf(self::WP_PACKAGE_NO_CONTENT_URL, $ver);
        $package->new_bundled = '';
        $package->partial = '';
        $package->rollback = '';

        $wpObj->packages = $package;


        $current = get_site_transient('update_core');
        $current->updates = array($wpObj);
        set_site_transient('update_core', $current);

		require_once ABSPATH . self::WP_FILE_SYSTEM_PATH;
        require_once ABSPATH . self::WP_UPGRADER_FILE_PATH;
        require_once ABSPATH . self::WP_MISC_PATH;
	  	wp_cache_flush();
        $upgrader = new Core_Upgrader();
        $result = $upgrader->upgrade($wpObj, ['attempt_rollback' => true]);


        if (is_wp_error($result)) {

            //TODO: handle failed updates - perhaps send an email and remove records from DB

            // keep status of update
            $this->updateAttempt['failed'][] = $attempt;

            error_log("Error occurred during update of WP core --> {$ver}");
            error_log(self::ERROR_DESCRIPTION . json_encode($result->get_error_message()));
        } else {

            // keep status of update
            $this->updateAttempt['successful'][] = $attempt;

            error_log("Updated WP core v{$ver} successfully");
        }

        // update records for this item
        $this->updateItemRecords($type, $slug, $this->updateAttempt);

    }

    /**
     * Update single item
     * @param $type string Type of item (plugins/themes/core)
     * @param $slug string Filename of the item
     * @param $ver string Desired version for update
     * @return void
     */
    public function updateSingle($type, $slug, $ver): void
    {

        // call update method based on item type
        call_user_func(
            array($this, "updateType" . ucfirst($type)),
            $type,
            $slug,
            $ver
        );

        // alternate dynamic function call
        //[$this, "updateType".ucfirst($type)]($type,$slug,$ver);

        // select suitable WP's update method based on received params
        // remove entry for this item from Settings in DB. So that its admin notice will go away.
        // add slug in updateState array.
    }


    /**
     * Auto update items
     */
    public function updateItems()
    {
        $items = $this->settings->get();
        $this->items = $items['vulnerabilities'];


        $this->updateAttempt['time'] = time();
        foreach ($this->items as $type => $vuls) {

            if ("wp" === $type) {
                $this->updateSingle($type, $type, $vuls['fixed_in']);
                continue;
            }

            foreach ($vuls as $slug => $item) {
                // skip if fix version not present
                if (empty($item['fixed_in'])) {
                    continue;
                }
                $this->updateSingle($type, $slug, $item['fixed_in']);
            }
        }

        // send email with param updateState array

    }

}